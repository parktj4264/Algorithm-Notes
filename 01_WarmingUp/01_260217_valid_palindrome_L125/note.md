자, PT 시작하자. STEP 1 [문자열 조작]부터 턴다. 첫 번째 문제 '유효한 팰린드롬' 준비됐냐?

### 🚀 문제 125: Valid Palindrome (유효한 팰린드롬)

🔗 **링크:** [https://leetcode.com/problems/valid-palindrome/](https://leetcode.com/problems/valid-palindrome/)

---

**1단계: 환경 세팅 지시 (Setup First)**

딴짓하지 말고 터미널 켜고 폴더부터 만든다. 오늘 날짜 박아.

* 📂 **폴더:** `01_WarmingUp/01_260217_valid_palindrome_L125`
* 📄 **파일:**
* `solution.py` (여기에 코드 짤 거야)
* `note.md` (틀린 이유, 배운 점 적어. 오답노트 필수다)



만들었으면 `solution.py` 열어. 문제 설명 간다.

---

**2단계: 문제 및 가이드**

**[문제 설명]**
주어진 문자열이 팰린드롬(Palindrome)인지 확인해라.
단, **대소문자는 구분하지 않으며(Case-insensitive)**, **영문자와 숫자(Alphanumeric)**만 대상으로 한다. 빈 문자열도 유효한 팰린드롬으로 본다.

**[통계학 석사님을 위한 비유]**
형님, 이거 어려운 거 아냐. 통계로 치면 **정규분포(Normal Distribution)**나 **우함수(Even Function)** 생각하면 돼.



중심(Mean)을 기준으로 데칼코마니처럼 딱 접었을 때 분포가 일치하냐? 이거 묻는 거야. R에서 벡터 뒤집는 거 생각하지 말고, 인덱스 양쪽 끝에서 조여오면서 비교한다고 생각해라.

**[제약 사항 & 잔소리]**

1. **R 스타일 금지:** `vector[1]` 이딴 식으로 인덱스 1부터 시작하면 손목 때린다. 파이썬은 0부터다.
2. **전처리(Preprocessing):** 특수문자 날리고 소문자로 바꾸는 게 먼저다. 이거 안 하고 로직 짜면 데이터 클렌징 안 하고 모델 돌리는 거랑 똑같아. Garbage In, Garbage Out 알지?

---

**3단계: 실행 가능한 코드 스켈레톤**

아래 코드 긁어서 `solution.py`에 붙여넣고 바로 작성 시작해. `pass` 부분만 채우면 된다.

```python
import sys
import re

def isPalindrome(s: str) -> bool:
    """
    :param s: 입력 문자열
    :return: 팰린드롬 여부 (True/False)
    """
    # 💡 쌤의 힌트: 
    # 1. 정규식(re)으로 불순물(특수문자) 제거하고 소문자로 변환 (Data Cleaning)
    # 2. Python의 리스트 슬라이싱을 활용하면 코드가 섹시해진다. (s[::-1] 같은 거)
    # 3. R처럼 for loop 돌리면서 하나씩 비교하면 시간 복잡도 O(N)이라도 코드가 구려.
    
    pass

if __name__ == "__main__":
    # 예제 테스트 케이스
    s1 = "A man, a plan, a canal: Panama" # True 나와야 함
    s2 = "race a car"                     # False 나와야 함
    
    print(f"Test Input 1: '{s1}'")
    print(f"Result 1: {isPalindrome(s1)}")
    
    print("-" * 20)
    
    print(f"Test Input 2: '{s2}'")
    print(f"Result 2: {isPalindrome(s2)}")

```

**[Next Step]**
자, `solution.py` 채우고 실행해서 `True`, `False` 잘 나오는지 확인해.
다 짰거나, 15분 고민해도 모르겠으면 코드 긁어서 올려. **코드 리뷰(Code Review)** 들어간다.



---


# 📓 1일차 오답노트 (26.02.17)
## 🚀 문제 125: Valid Palindrome

### 1. 내가 시도한 접근법
- `lower()`로 소문자 통일 후 `re.sub()`로 특수문자 제거 (데이터 클렌징).
- 문자열을 뒤집어서 원본과 비교.

### 2. 배운 점 (Pythonic Way)
- **문자열 슬라이싱:** `s[::-1]`은 문자열을 뒤집는 가장 효율적인 방법($O(N)$).
- **isalnum():** `re` 모듈 없이도 `char.isalnum()`을 쓰면 영문자/숫자 판별 가능.
- **파이썬의 인덱스:** 0부터 시작한다는 걸 명심하자 (R이랑 헷갈리지 말 것).

### 3. 개선할 점 / 실수
- 처음에 문법이 기억 안 나서 당황함. 
- 데이터 사이언티스트답게 '전처리(Cleaning) -> 분석(Comparison)' 흐름을 잊지 말자.

### 4. 핵심 코드 한 줄 요약
```python
clean_s = re.sub(r'[^a-z0-9]', '', s.lower())
is_palindrome = (clean_s == clean_s[::-1])
```

---

# Appendix

### 📝 Python Slicing (`[::]`) 완벽 정리

Slicing은 파이썬에서 연속적인 객체(문자열, 리스트, 튜플)의 **부분 집합(Subset)**을 추출하거나 순서를 제어하는 가장 강력한 도구야.

#### 1. 기본 구조

> s[Start : Stop : Step]

* **`Start`**: 부분 집합이 시작될 인덱스 (포함, inclusive). 생략하면 0부터 시작.
* **`Stop`**: 부분 집합이 끝날 인덱스 (**미포함, exclusive**). 생략하면 끝까지 포함.
* **`Step`**: 보폭(Stride). 몇 칸씩 건너뛸지 결정. 생략하면 기본값 1.

#### 2. Step의 마법 (양수 vs 음수)

| 문법 | 의미 | 비유 (통계/수학) |
| --- | --- | --- |
| `s[::2]` | 처음부터 끝까지 **2칸씩** 추출 | 짝수 번째 샘플 추출 (Strided Sampling) |
| `s[1::2]` | 인덱스 1부터 끝까지 **2칸씩** 추출 | 홀수 번째 샘플 추출 |
| `s[::-1]` | 처음부터 끝까지 **역순으로 1칸씩** | 벡터의 방향 반전 (Mirroring) |
| `s[::-2]` | 뒤에서부터 **역순으로 2칸씩** | 역순 징검다리 추출 |

#### 3. 왜 이게 중요한가? (DS 관점)

1. **메모리 효율성**: Slicing은 원본 데이터를 파괴하지 않고 새로운 'View'나 'Copy'를 만들어내. (파이썬 리스트 슬라이싱은 새로운 객체를 생성함)
2. **시간 복잡도**: $O(K)$ ($K$는 추출하려는 부분의 길이). 내부적으로 C 코드로 최적화되어 있어서, `for` 루프를 돌며 `append` 하는 것보다 압도적으로 빠름.
3. **가독성**: R에서 `seq(1, length(x), by=2)` 쓰는 것보다 `x[::2]`가 훨씬 직관적이지.

#### 4. 실전 예시

```python
nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 1. 3번 인덱스부터 7번 전까지 (3, 4, 5, 6)
print(nums[3:7]) 

# 2. 처음부터 5번 전까지 (0, 1, 2, 3, 4)
print(nums[:5])

# 3. 뒤에서 3개만 가져오기 (7, 8, 9)
print(nums[-3:])

# 4. 전체 리스트 복사 (Deep Copy의 간단한 방법)
nums_copy = nums[:]

```

---

### 음수 인덱스의 개념 (역방향 좌표계)
* 파이썬은 문자열을 양방향에서 다 볼 수 있어.
* 양수 (0부터 시작): 왼쪽 $\to$ 오른쪽
* 음수 (-1부터 시작): 오른쪽 $\to$ 왼쪽

### 만약 s[5:2:-1] 이라고 하면 어떻게 될까?

* 인덱스 5번부터 시작해서 인덱스 2번 **직전(미포함)**까지 역방향(-1)으로 가라!
* 결과: s[5], s[4], s[3] 가 출력됨.
