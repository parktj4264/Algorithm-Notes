자, PT 시작하자. 헛바람 싹 빼고 다시 파이썬으로 돌아온 거 환영한다. ㅋㅋㅋ
현재 진도: **STEP 1 (워밍업) ➔ [진행 중: 3/38]**

세 번째 문제는 파이썬의 꽃, **'문자열 파싱'**과 **'다중 조건 정렬(Lambda)'**을 뼈저리게 느끼게 해줄 문제다. 몰로코 가려면 데이터 전처리 속도가 생명인 거 알지? 바로 들어간다.

### 🚀 문제 937: Reorder Data in Log Files (로그 파일 재정렬)

🔗 **링크:** [https://leetcode.com/problems/reorder-data-in-log-files/](https://leetcode.com/problems/reorder-data-in-log-files/)

---

**1단계: 환경 세팅 지시 (Setup First)**

노트북 켰으면 터미널부터 열어라.

* 📂 **폴더:** `01_WarmingUp/03_260220_reorder_log_files_L937`
* 📄 **파일:** `solution.py`, `note.md`

만들었으면 `solution.py` 열어.

---

**2단계: 문제 및 가이드**

**[문제 설명]**
로그 데이터 배열이 주어진다. 각 로그의 첫 번째 단어는 '식별자(Identifier)'다. 로그를 다음 규칙에 따라 재정렬해라.

1. **문자 로그(Letter-logs)**가 **숫자 로그(Digit-logs)**보다 항상 앞에 온다.
2. 문자 로그는 '내용물(Contents)'을 기준으로 사전순(알파벳순) 정렬한다.
3. 내용물이 완전히 똑같으면, '식별자(Identifier)'를 기준으로 사전순 정렬한다.
4. 숫자 로그는 정렬하지 않고 **입력된 원래 순서를 그대로 유지**한다.

**[통계학 석사님을 위한 비유]**
형님, R에서 데이터프레임 다룰 때 `dplyr::arrange(data, var1, var2)` 써서 1순위 조건, 2순위 조건으로 정렬해 봤지? 딱 그거야.
그리고 4번 조건의 "원래 순서를 유지한다"는 건 전산학/통계학에서 말하는 **'안정 정렬(Stable Sort)'**의 개념이야. 파이썬의 내장 `sort()` 함수는 기본적으로 이 '안정 정렬'을 지원하니까 숫자 로그는 그냥 냅두기만 하면 알아서 순서가 지켜져. 개꿀이지?

**[제약 사항 & 잔소리]**

1. 처음부터 전부 다 정렬하려고 하지 마. 데이터 클렌징하듯 **'문자 로그 배열'**과 **'숫자 로그 배열'**을 먼저 분리(Filtering)하는 게 1빠따다. `split()` 함수를 써서 쪼개봐.
2. 파이썬에서 다중 조건 정렬을 할 때는 **`lambda` (익명 함수)**가 핵심이야. R에서 `apply` 계열 함수 안에 `function(x)` 넣어서 일회용으로 쓰던 거랑 완벽하게 똑같은 놈이다.

---

**3단계: 실행 가능한 코드 스켈레톤**

아래 코드 긁어서 `solution.py`에 붙여넣고 작성을 시작해라.

```python
import sys
from typing import List

def reorderLogFiles(logs: List[str]) -> List[str]:
    """
    :param logs: 로그 문자열 리스트
    :return: 조건에 맞게 재정렬된 로그 리스트
    """
    letters, digits = [], []
    
    # 💡 쌤의 힌트:
    # 1. 반복문을 돌면서 이게 문자 로그인지 숫자 로그인지 판별해서 letters, digits 리스트에 각각 넣는다.
    #    (파이썬 문자열 메서드인 split()과 isdigit()을 적극 활용할 것)
    # 2. letters 리스트를 정렬한다. 
    #    sort()에 key=lambda x: (1순위 정렬기준, 2순위 정렬기준) 형태로 튜플을 넘겨주면 됨.
    # 3. 정렬된 letters와 원래 순서 그대로인 digits를 합쳐서(+) 리턴한다.
    
    pass

if __name__ == "__main__":
    # 예제 테스트 케이스 1
    logs1 = ["dig1 8 1 5 1","let1 art can","dig2 3 6","let2 own kit dig","let3 art zero"]
    print("Test Input 1:")
    for log in logs1: print(f"  {log}")
    
    result1 = reorderLogFiles(logs1)
    print("\nResult 1:")
    for log in result1: print(f"  {log}")
    # 정답: ["let1 art can","let3 art zero","let2 own kit dig","dig1 8 1 5 1","dig2 3 6"]
    
    print("-" * 40)
    
    # 예제 테스트 케이스 2
    logs2 = ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
    print("Test Input 2:")
    for log in logs2: print(f"  {log}")
    
    result2 = reorderLogFiles(logs2)
    print("\nResult 2:")
    for log in result2: print(f"  {log}")
    # 정답: ["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]

```

**[Next Step]**
이번 문제는 파이썬의 강력한 기능(`split`, `isdigit`, `lambda`)을 얼마나 찰지게 쓰느냐가 관건이야.
`solution.py` 채워서 돌려보고 정답 나오면 코드 올려라. `lambda` 함수 제대로 썼는지 리뷰해 줄게! 실시!





---
---

  

---

### 1. 문제 완벽 이해 (DS 맞춤형 번역)

형님, 입력으로 들어오는 로그 데이터 하나하나를 **2개의 컬럼을 가진 데이터 프레임의 행(Row)**이라고 생각해 봐.

로그 예시: `"dig1 8 1 5 1"`, `"let1 art can"`
이걸 띄어쓰기 기준으로 맨 앞단어는 **`식별자(ID)`**, 그 뒷부분은 **`내용(Content)`**으로 분리할 수 있어.

| 원본 문자열 | 식별자 (ID) | 내용 (Content) | 타입 |
| --- | --- | --- | --- |
| `"dig1 8 1 5 1"` | `"dig1"` | `"8 1 5 1"` | 숫자 로그 (내용이 숫자) |
| `"let1 art can"` | `"let1"` | `"art can"` | 문자 로그 (내용이 영문) |

**[정렬 미션 (SQL/R의 `ORDER BY`)]**

1. **Filtering:** 일단 '문자 로그'랑 '숫자 로그'를 두 그룹으로 찢어라. (`subset` 하듯이)
2. **Sorting (문자 그룹):** 문자 로그들만 모아서 정렬을 때린다.
* 1순위 정렬 기준: `내용 (Content)` (오름차순)
* 2순위 정렬 기준: `식별자 (ID)` (내용이 완전히 똑같을 때만)


3. **No Sorting (숫자 그룹):** 숫자 로그는 정렬하지 말고, 원래 들어온 순서 그대로 둬라.
4. **Concat:** 정렬 끝난 [문자 로그 그룹] 뒤에 [숫자 로그 그룹]을 냅다 이어 붙여서(`rbind` 또는 `pd.concat`) 리턴해라.

---





<br>
<br>
<br>
<br>
<br>



# 📓 3일차 오답노트 (26.02.20)
## 🚀 문제 937: Reorder Data in Log Files (로그 파일 재정렬)

### 1. 내가 짠 코드의 장점과 찝찝함
- **장점:** `split(" ", 1)`과 `isdigit()`을 활용해 숫자/문자 로그를 완벽히 Filtering 함.
- **찝찝함:** 정렬할 때 `split()`을 반복 호출해서 비효율적이라 느꼈음.
- **PT 쌤 피드백:** 파이썬 `.sort()`는 C로 최적화되어 있어, 메모리를 추가로 써서 파싱된 데이터를 저장하는 것보다 `lambda` 안에서 즉석으로 `split()`을 다시 호출하는 것이 파이썬 생태계에서는 더 빠르고 표준적인(Pythonic) 방식임.

### 2. 배운 점 (Lambda와 다중 조건 정렬)
- 파이썬 리스트 병합은 `+` 연산자로 매우 쉽게 가능하다 (`letters + digits`).
- `변수명 id`는 파이썬 내장 함수이므로 피하는 것이 좋다.
- **`lambda x: (조건1, 조건2)`**: `.sort(key=...)`와 결합하여 정렬을 위한 **'파생 변수(기준값)'**를 일회성으로 던져주는 매핑 함수 역할을 한다.

### 3. 핵심 코드 (The Pythonic Way)
```python
letters.sort(key=lambda x: (x.split(" ", 1)[1], x.split(" ", 1)[0]))
return letters + digits
```



  
    
      
  

<br>
<br>
<br>


---

# APPENDIX

아, 람다(lambda)! 여기서 벽 느끼는 거 완전 정상임. ㅋㅋㅋ 함수 이름도 없고 `def`도 안 쓰니까 갑자기 외계어처럼 보이거든.

네가 R에서 `purrr` 패키지 쓸 때 `map(data, ~ .x)` 하거나, Base R에서 `lapply(data, function(x) ...)` 처럼 일회용 익명 함수(Anonymous Function) 만들어 쓴 경험 있지? 파이썬의 `lambda`가 정확히 그 역할이야. **"이름 붙여서 저장하긴 아까운 일회용 짬타이거 함수"**라고 생각하면 편해.

이 코드를 현미경 들이대고 하나씩 쪼개서 수술대 위에 올려보자.

### 1. `lambda x:` 의 진짜 의미

여기서 `x`는 리스트 안에 들어있는 **로그 문자열 데이터 하나하나**를 뜻해.
`.sort()` 함수가 리스트 안의 데이터를 순회하면서, 각 원소를 저 `lambda` 함수의 `x` 자리에 쏙쏙 집어넣는 거야.

* `x`에 `"let1 art can"` 이라는 데이터가 들어왔다고 치자.

### 2. 튜플 `( )`을 만들어내는 공장

`lambda` 뒤에 있는 콜론(`:`) 다음 부분은 **"입력받은 `x`를 지지고 볶아서 이걸 뱉어내라!"**는 뜻이야.
근데 괄호 `( )`로 묶여 있지? 즉, 튜플을 만들어서 뱉어내라는 거지.

튜플 안의 두 요소를 뜯어보자:

* **첫 번째 요소 (1순위 기준):** `x.split(" ", 1)[1]`
* `"let1 art can"`을 첫 공백 기준으로 쪼개면 `["let1", "art can"]`이 됨.
* 여기서 `[1]` 인덱스를 가져오니까 👉 **`"art can"`** (로그의 내용)


* **두 번째 요소 (2순위 기준):** `x.split(" ", 1)[0]`
* 똑같이 쪼갠 리스트에서 `[0]` 인덱스를 가져오니까 👉 **`"let1"`** (로그의 식별자)



결과적으로 `x = "let1 art can"`이 람다 함수를 통과하면 **`("art can", "let1")`** 이라는 튜플표가 하나 뚝딱 만들어져서 나와.

### 3. `.sort(key=...)`의 숨겨진 작동 로직

여기가 네가 가장 헷갈려하는 포인트일 거야. "이 튜플을 만들어서 어쩌라는 건데?" 싶지?

파이썬의 `.sort()`는 데이터를 직접 비교하기 전에, **`key`에 지정된 함수(여기선 람다)한테 원소들을 하나씩 다 던져봐.**
그리고 람다가 뱉어낸 그 결과물(튜플)을 **'정렬을 위한 임시 번호표'**로 써.

1. 원본 데이터: `"let1 art can"`
2. 람다가 만들어준 번호표: `("art can", "let1")`
3. `.sort()`의 생각: "아하! 원본 데이터는 냅두고, 일단 이 번호표들끼리 사전순으로 줄을 세워야겠다. 첫 번째 단어(`art can`)로 먼저 줄 세우고, 똑같으면 두 번째 단어(`let1`)로 줄 세워야지!"

줄 세우기가 완벽하게 끝나면? **저 임시 번호표(튜플)들은 메모리에서 깔끔하게 날려버리고, 줄 서있는 원본 데이터들만 남겨놔.**

### 4. 왜 이게 우아한가? (Tiny Data 관점)

네가 R에서 데이터프레임 다룰 때 파생 변수 컬럼을 2개나 새로 파서(메모리 할당) 정렬한 다음, 다시 그 컬럼들을 `NULL`로 날려버리는 짓을 한다고 생각해 봐. 얼마나 비효율적이야?

파이썬의 이 `key=lambda` 방식은 새로운 데이터 구조를 영구적으로 메모리에 올리지 않아. Timsort 알고리즘이 원소들의 위치를 비교할 때만 **Lazy evaluation(지연 평가)** 느낌으로 살짝 람다를 호출해서 번호표만 확인하고 버리는 식이지. 코드가 곧 지식자산이고 메모리 효율을 극대화해야 한다는 관점에서 보면, 굉장히 깔끔하고 구조적인 설계인 거야.

---

<br>
<br>
<br>
<br>
<br>


### 1. `key`의 정체: `.sort()`가 뚫어놓은 '함수 전용 파라미터'

`.sort()` 함수는 기본적으로 오름차순 정렬을 해. 근데 "야, 내 맘대로 커스텀 정렬 기준을 주고 싶은데?" 할 때를 대비해서 `.sort(key=...)`라는 자리를 만들어 놨어.
여기서 중요한 건, **`key=` 자리에는 무조건 '함수'가 들어가야 해.** (문자열이나 숫자가 들어가면 에러 남)

### 2. 정식 함수(`def`)를 쓰면 람다가 필요 없음 (세트가 아니라는 증거)

`lambda`를 쓰기 싫거나 이해가 안 가면, 그냥 파이썬의 정식 함수를 만들어서 `key`에 던져줘도 완벽하게 똑같이 동작해.

```python
# 1. 정식으로 각 잡고 함수(이름: get_sort_criteria)를 하나 만듦
def get_sort_criteria(x):
    content = x.split(" ", 1)[1] # 1순위: 내용
    id_name = x.split(" ", 1)[0] # 2순위: 식별자
    return (content, id_name)

# 2. sort()의 key 파라미터에 그 함수 '이름'만 딱 넘겨줌
letters.sort(key=get_sort_criteria)

```

봐봐, `lambda`란 단어가 아예 없지? 이렇게 `key`는 그냥 "기준을 뽑아내 줄 함수 아무거나 줘!" 하는 역할일 뿐이야.

### 3. `lambda`의 정체: 굳이 이름 짓기 귀찮을 때 쓰는 '1회용 함수'

그럼 아까처럼 `def`로 정식 함수를 만들면 되는데 왜 굳이 `lambda`를 쓸까?

저 `get_sort_criteria`라는 함수는 오직 저 줄 세우기 한 번을 위해 태어난 애잖아? 다른 데서는 절대 안 써. 근데 굳이 `def` 써가며 메모리 한구석에 이름표까지 붙여서 짱박아 두는 게, 코드 가독성도 떨어지고 설계 관점에서도 별로 안 예쁘단 말이지.

그래서 **"야, 어차피 여기서 딱 한 번 쓰고 버릴 건데 굳이 이름 짓지 말자. 그냥 그 자리에서 즉석으로 함수 만들어서 `key`에 꽂아버리자!"** 하고 쓰는 게 `lambda x: ...` 인 거야.

* `lambda x:` 👉 "입력값 x를 받아서"
* `(...)` 👉 "이 튜플을 뱉어내는 익명 함수 완성!"

---


<br>
<br>
<br>

### 1. 정식 함수(def) vs 1회용 자판기(lambda) 비교

숫자 하나를 입력받아서 제곱()을 반환하는 기능을 만든다고 쳐보자.

**① 정식 공장 설립 (`def` 사용)**

```python
def square_factory(x):
    return x ** 2

print(square_factory(4))  # 결과: 16

```

**② 길거리 1회용 포장마차 (`lambda` 사용)**

```python
print((lambda x: x ** 2)(4))  # 결과: 16

```
