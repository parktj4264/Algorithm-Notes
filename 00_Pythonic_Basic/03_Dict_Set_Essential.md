# 🔑 03_Dict_Set_Essential — Hash Table Implementation

## 0. Overview

데이터가 10개든 100억 개든 검색 속도가 무조건 O(1).

* **Target:** "리스트에서 `if x in list:` 쓰다가 시간 초과(Time Limit) 터진 사람."
* **Goal:** 파이썬 `dict`와 `set`의 근간이 되는 **해시 테이블(Hash Table)**의 수학적 동작 원리를 이해하고, 실무에서 `KeyError` 없이 우아하게 데이터를 세고 묶는 법을 배운다.
* **Key Concept:** `Hash Function`, `Collision (Open Addressing)`, `Load Factor`, `O(1)`.

---

## 1. Low-Level Theory: 해시(Hash)의 3대장 🧠

### 1-1. Hash Function (해시 함수): 주소 연금술

딕셔너리가 $O(1)$의 기적을 보여주는 핵심 원리야. 데이터를 처음부터 끝까지 뒤지는 게(Search) 아니라, **데이터 자체가 자기 주소를 계산해 내는 방식**이야.

* **원리:**
1. 문자열 키 `"Taejun"`을 **해시 함수**에 넣는다.
2. 아주 긴 랜덤한 정수(예: `84729104...`)가 튀어나온다.
3. 이 숫자를 현재 배열 크기 으로 나눈 나머지()를 구한다.
4. 그 나머지 값이 바로 데이터가 들어갈 **메모리 인덱스(방 번호)**가 된다.

* 이때, 모두가 처음에 같은 방을 배정받아도, 충돌이 날 때마다 파이썬이 규칙적인 랜덤 점프를 뛰어서 빈방을 기어코 찾아내서 쑤셔 넣음



### 1-2. Collision Resolution (충돌 해결): 비둘기집 원리

방은 8개인데, 들어갈 데이터가 10개면? 필연적으로 "같은 방 번호"를 배정받는 놈들이 생겨. 이걸 **충돌(Collision)**이라고 해.

* **해결법 A: Chaining (자바/C++ 방식)**
* 방에 사람이 이미 있으면, 그 사람 뒤에 끈(Linked List)으로 묶어서 줄을 세움.
* RAM 관점에서는 데이터가 파편화 되어있어서 시간이 더 걸림. (Cache Miss)


* **해결법 B: Open Addressing (파이썬 방식) 🔥**
* 파이썬은 **"남의 방에 빈자리 있으면 그냥 거기 들어간다"**는 개방 주소법을 써.
* 방이 꽉 차 있으면? 파이썬 내부의 특수한 난수 발생기를 돌려서 다음 빈방(Probing)을 찾아감.
* **왜 이걸 쓸까?** 어제 배운 **CPU Cache Hit** 때문이야. Chaining은 메모리가 여기저기 흩어지지만, Open Addressing은 배열 내부에 데이터가 오밀조밀 모여 있어서 캐시 지역성(Locality)이 압도적으로 좋음.





### 1-3. Load Factor (적재율): 확장의 임계점

남의 빈방을 찾아 들어가는(Open Addressing) 방식의 치명적 단점은 **"방이 거의 다 차가면 빈방 찾느라 무한 루프()를 돈다"**는 거야.

* **파이썬의 방어 기제:**
* 파이썬 딕셔너리는 방이 **2/3 (약 66.6%)** 차는 순간, "아 좁아!" 하고 메모리 크기를 **2배~4배**로 뻥튀기해 버려.
* 이 66.6%를 **Load Factor(적재율)**라고 불러.
* 즉, 파이썬 딕셔너리는 언제나 **최소 1/3의 공간을 빈방으로 낭비**하면서 $O(1)$의 속도를 유지하는 극단적인 "메모리-속도 교환" 구조야.



---

## 2. Practical Guide: 실무 조작의 정석 (Step-by-Step)

### Step 1: Basic Operations (기초 체력)

기본적인 추가, 삭제, 조회 방법. 특히 조회할 때 `[]` 대신 `get()`을 쓰는 습관이 중요해.

| 기능 | 코드 | 설명 | 비유 |
| --- | --- | --- | --- |
| **생성** | `d = {}` 또는 `d = dict()` | 해시 테이블 생성 | 빈 호텔 짓기 |
| **추가/수정** | `d["name"] = "Taejun"` | 키가 없으면 추가, 있으면 덮어씀. | 투숙객 등록 |
| **삭제** | `del d["name"]` | 해당 키 완전 삭제. | 강제 퇴실 |
| **조회 (위험)** | `val = d["age"]` | **[주의]** 키 없으면 `KeyError`로 프로그램 터짐. | 문 따고 들어가기 |
| **조회 (안전)** | `val = d.get("age", 0)` | 키가 없으면 0(기본값)을 반환. 안 터짐! | 프론트에 물어보기 |

### Step 2: Evolution (Pythonic Tools) 🚀

데이터 분석이나 알고리즘 문제 풀 때, 매번 "이 키가 딕셔너리에 있나?" 체크하는 건 하수야. 고수들은 `collections` 모듈을 써. R의 `table()` 함수 뺨치는 강력한 도구들이야.







#### 2-1. `defaultdict`: `KeyError`의 완벽한 예방

* **Legacy (하수):**
```python
d = {}
for word in words:
    if word not in d:  # 👈 매번 확인해야 함 (귀찮음)
        d[word] = 0
    d[word] += 1
```


* **Modern (고수):**
```python
from collections import defaultdict
d = defaultdict(int)  # 👈 없는 키를 부르면 알아서 0으로 초기화해 줌
for word in words:
    d[word] += 1      # 조건문 싹 다 사라짐 (깔끔)
```

> **[메뉴얼]**
> "손님이 없는 방 번호(Key)를 부르면, 절대 당황해서 에러(`KeyError`) 내지 마!
> 그 즉시 뒤돌아서 **`int()` 함수를 실행해.** > 그럼 `0`이 나오겠지? 그걸 그 빈방에 먼저 쓱 넣어두고, 손님한테 그 `0`을 줘라."






#### 2-2. `Counter`: 빈도수 계산의 끝판왕

* 데이터를 리스트로 던져주면, 알아서 종류별로 몇 개인지 다 세어줌. (내부적으로 C언어 레벨에서 초고속 해싱 처리)
```python
from collections import Counter
data = ['apple', 'apple', 'banana', 'apple', 'cherry']

counts = Counter(data)
print(counts)  # 출력: Counter({'apple': 3, 'banana': 1, 'cherry': 1})

# 꿀팁: 가장 많이 나온 탑 2개 뽑기
print(counts.most_common(2)) # [('apple', 3), ('banana', 1)]

```



### 👑 파이썬 해시(Hash) 3형제 완벽 비교 요약

| 구분 (Type) | 🚗 `dict` (순정 깡통차) | 🚓 `defaultdict` (안전 튜닝카) | 🚜 `Counter` (데이터 포크레인) |
| --- | --- | --- | --- |
| **태생 (족보)** | 파이썬 내장(Built-in) 근본 객체 | `collections` 모듈 (`dict` 상속) | `collections` 모듈 (`dict` 상속) |
| **비유하자면?** | 깐깐한 프론트 직원 | 눈치 빠른 만능 프론트 직원 | 빈도수 계산 전문 회계 법인 |
| **없는 키 부를 때** | 🚨 **`KeyError` 발생 (프로그램 터짐)** | 🛡️ 설정한 기본값(0, `[]` 등) 자동 생성 | 🛡️ 그냥 `0`을 반환함 (에러 없음) |
| **최고의 장점** | 가장 기본적이고 가벼움. (메모리 낭비 X) | 지저분한 `if key in d:` 조건문을 싹 다 날려줌. | 리스트 통째로 던지면 C언어 엔진이 알아서 다 세어줌. |
| **단점 / 주의점** | 값 추가/조회 시 형이 직접 방어 코드를 짜야 함. (`.get()` 필수) | 오타 낸 키를 조회해도 에러가 안 나고 쓰레기 방이 무한 생성될 수 있음. | 무겁다. 단순 키-값 저장용으로 쓰기엔 오버스펙. |
| **실무/코테 용도** | 단순한 JSON 데이터 파싱, 1:1 매핑 데이터 저장 | 데이터 **그룹핑** (`list`), 누적 계산 (`int`) | 리스트/문자열 원소 **빈도수 계산, 순위 매기기** |
| **치트키 (문법)** | `d.get(key, 0)` | `d = defaultdict(list)` | `counts.most_common(3)` |
| **검색 속도** | **** | **** | **** |






---

## 3. Summary 📝

1. **딕셔너리와 셋의 검색 속도는 무조건 $O(1)$이다.** 데이터가 1억 개라도 바로 찾는다.
2. 이 속도는 **해시 함수(Hash Function)** 덕분이며, 데이터를 추가할 때 내부적으로 자기 주소를 직접 계산한다.
3. 파이썬은 충돌이 나면 빈방을 찾아가는 **Open Addressing**을 사용하며, 속도 유지를 위해 메모리의 1/3을 항상 비워둔다(Load Factor 2/3).
4. 키 개수를 세거나 그룹핑할 때는 생짜 딕셔너리 쓰면서 `if`문 도배하지 말고, 무조건 **`Counter`**나 **`defaultdict`**를 꺼내 들어라.
