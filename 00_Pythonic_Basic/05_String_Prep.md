드디어 **파이썬 기초 체력 커리큘럼의 마지막 보스**, 문자열(String) 파트야. 🎉

R에서 `paste()`나 `stringr` 패키지 쓰던 버릇 그대로 파이썬에서 `+` 기호로 문자열 합치다가, 데이터 수백만 줄 넘어가면 **서버 메모리 터지면서 프로그램 강제 종료(OOM)** 되는 경험 한 번쯤 해보게 될 텐데, 이 챕터가 바로 그 재앙을 막아주는 백신이야.

"문자열은 수정할 수 없다(Immutable)"는 파이썬의 독특한 철학과, 메모리 파편화를 막기 위한 `join()`의 우아함을 담은 마크다운 파일이야.

---

# ✂️ 05_String_Prep — Immutable Object & String Interning

## 0. Overview

* **Target:** "텍스트 전처리할 때 `for`문 돌면서 `s += word`로 문자열을 이어 붙이는 사람."
* **Goal:** 파이썬 문자열의 **불변성(Immutability)**을 이해하고, 이로 인해 발생하는 메모리 복사 오버헤드($O(N^2)$)를 `join()` 메서드로 우아하게 회피하는 방법을 배운다.
* **Key Concept:** `Immutable`, `String Interning`, `Garbage Collection`, `join()`, `re.sub()`.

---

## 1 Low-Level Theory: 문자열의 숨겨진 원리 🧠

### 1-1. Immutability (불변성): "한 번 태어난 문자열은 바뀔 수 없다"

파이썬에서 `list`는 안의 요소를 바꿀 수 있지만(`a[0] = 1`), `string`은 한 번 만들어지면 절대 수정할 수 없어 (`s[0] = 'A'` 🚨 에러 발생).

* **왜 이렇게 만들었을까?**
1. **안전성 (Thread-Safe):** 여러 곳에서 동시에 읽어도 값이 변할 일이 없으니 안전함.
2. **해시 가능 (Hashability):** 값이 안 변한다는 보장이 있어야 수학적 해시값(Hash)을 고정할 수 있어. **즉, 문자열이 불변하기 때문에 우리가 딕셔너리(`dict`)의 Key로 쓸 수 있는 거야.** (이전 챕터 `03_Dict`와 연결됨!)


* **함정:** `s = s.replace('a', 'b')` 같은 코드는 원래 문자열을 '수정'하는 게 아니야. 기존 걸 부수고 **아예 새로운 문자열 객체를 메모리에 새로 할당**하는 거임.






### 1-2. String Interning (문자열 인터닝): "똑같은 건 하나만 만들자"

파이썬은 메모리를 아끼기 위해 짧고 자주 쓰이는 문자열(특히 식별자 규칙을 따르는 문자열)은 **메모리에 딱 하나만 만들어두고 돌려써 (Singleton 기법)**.

```python
a = "Hello"
b = "Hello"
print(a is b)  # True (주소값이 완전히 똑같음!)

```

* **이점:** 문자열이 같은지 비교할 때(`a == b`), 글자를 하나하나 $O(N)$으로 비교할 필요 없이, 메모리 주소(Pointer)만 띡 비교하면 되니까  속도로 초고속 비교가 가능해짐.

### 1-3. Garbage Collection의 비극: `+` vs `join()` 💥

형, 이게 이 챕터의 핵심이야. `for`문 안에서 문자열을 `+`로 계속 더하면 무슨 일이 벌어질까?

* **`s += "a"`의 실제 동작 (O(N^2)의 재앙):**
1. 기존 문자열 크기 + `"a"` 크기만큼 **새로운 메모리 공간(집)**을 계약함.
2. 기존 글자들을 새집으로 전부 이사(Copy)시킴.
3. `"a"`를 끝에 붙임.
4. 헌 집은 Garbage Collector(청소부)가 부숨.


* ➡️ 이걸 1만 번 반복하면? **이사만 1만 번 다니면서 메모리가 갈기갈기 찢어짐(Fragmentation).** 시간도  걸림.


* **`"".join(list)`의 기적 (O(N)의 구원):**
* 리스트에 있는 모든 문자열의 길이를 **딱 한 번 미리 계산**함.
* 전체 길이만큼의 **거대한 메모리 공간(새집)을 딱 한 번만 할당**함.
* 거기에 값들을 한 번에 쭉쭉 밀어 넣음. (이사 1번으로 끝!)



---

## 2. Practical Guide: 실무 전처리 정석 (Step-by-Step)

### Step 1: 필수 문자열 메서드 4대장

MSR(Metrology) 로그나 텍스트 데이터 들어오면 숨 쉬듯이 써야 하는 메서드들이야. 전부 **새로운 문자열을 반환**한다는 걸 명심해.

| 기능 | 코드 | 설명 |
| --- | --- | --- |
| **쪼개기** | `s.split("_")` | "Wafer_01" ➡️ `["Wafer", "01"]` (결과가 **리스트**로 나옴) |
| **합치기** | `"_".join(["A", "B"])` | `["A", "B"]` ➡️ "A_B" (`+` 대신 무조건 이거 써야 함) |
| **치환** | `s.replace("A", "B")` | "A"를 "B"로 통째로 바꿈 (빠르지만 단순함) |
| **대소문자** | `s.upper()`, `s.lower()` | 비교나 검색하기 전에 텍스트 정규화할 때 필수. |

### Step 2: Evolution (Slicing & Regex) 🚀

단순 치환을 넘어선 파이썬의 고급 무기들.

#### (1) 슬라이싱 (C레벨 초고속 가공)

파이썬은 문자열을 배열처럼 다룰 수 있어. `s[start:end:step]` 문법은 C언어 레벨에서 처리돼서 미친 듯이 빨라.

* `s[::-1]`: 문자열 전체를 **초고속으로 뒤집음** (Reverse).
* `s[-4:]`: "Log_File_**2026**"처럼 맨 끝의 연도나 확장자만 뽑아낼 때 유용함.

#### (2) 정규식 (Regular Expression) `re` 모듈

`replace`로는 처리 안 되는 복잡한 패턴(예: "숫자 뒤에 오는 특수기호만 다 지워라")은 무조건 정규식이야.

```python
import re
log_data = "Error 404: Wafer_Yield is 0.98!! #Fail"

# 패턴: 숫자와 영문자, 점(.)을 제외한 모든 특수기호 제거
clean_data = re.sub(r'[^a-zA-Z0-9.\s]', '', log_data) 
# 결과: "Error 404 WaferYield is 0.98 Fail"

```

---

## 3. Summary for R User 📝

1. **R의 `paste0()`는 파이썬의 `join()`이다.** 반복문 안에서 `+` 연산자로 문자열을 합치는 건 범죄 행위다.
2. 문자열은 한 번 생성되면 **불변(Immutable)**이다. 따라서 `upper()`, `replace()`를 쓸 때는 반드시 **변수에 다시 할당(`s = s.replace()`)**해줘야 한다.
3. 파이썬은 자주 쓰는 문자열을 캐싱(**Interning**)하므로 문자열 비교(`==`)가 매우 빠르다. 딕셔너리 Key로 쓰기 완벽한 스펙이다.

---


---


## Appendix. 정규식



`replace`로는 "정확히 일치하는 단어"만 바꿀 수 있어. 하지만 현업의 로그 데이터는 `ERR_001`, `ERR_099`처럼 패턴만 같고 값이 계속 변하잖아? 이때는 무조건 정규식을 꺼내야 해.

### **💡 필수 암기 정규식 룬(Rune) 문자:**

* `\d` : 숫자 1개 (0~9)
* `\w` : 문자, 숫자, 언더바(`_`) 1개 (단어 구성 요소)
* `+` : 앞의 문자가 **1개 이상** 연속됨 (예: `\d+` = 숫자가 1개 이상 뭉쳐있음)
* `*` : 앞의 문자가 **0개 이상** (없을 수도 있음)
* `^` / `$` : 각각 문자열의 **시작** / **끝**

### **🔥 실전 3대장 패턴 (이것만 알면 텍스트 전처리 90% 끝남)**

#### **1. `re.findall()` : 조건에 맞는 데이터 싹 다 수집 (추출)**
더러운 텍스트 뭉치에서 특정 규칙을 가진 데이터만 리스트로 쏙쏙 뽑아낼 때 써.

```python
import re

log_text = "Lot_A wafer_01 failed with ERR_404. Lot_B wafer_12 passed. Error code ERR_502 detected."

# 미션: "ERR_숫자" 패턴만 전부 뽑아내라!
# 해석: ERR_ 뒤에 숫자(\d)가 1개 이상(+) 붙어있는 놈들
error_codes = re.findall(r'ERR_\d+', log_text)

print(error_codes) 
# 출력: ['ERR_404', 'ERR_502']

```

#### **2. `re.sub()` : 패턴으로 뭉텅이 치환 (노이즈 정제)**
R의 `gsub()`이나 `str_replace_all()`과 완벽히 똑같아. 쓸데없는 로그 찌꺼기를 날려버릴 때 개꿀이야.

```python
messy_data = "Wafer_Yield: 0.98!!! @#% Check required..."

# 미션: 숫자(\d), 마침표(.), 알파벳(\w), 공백(\s) 빼고(^) 싹 다 날려라!
clean_data = re.sub(r'[^\w\s.]', '', messy_data)

print(clean_data)
# 출력: "Wafer_Yield 0.98  Check required"

```

#### **3. 그룹 캡처 `()` : 데이터 쪼개서 발라내기 (핵심 스킬)**
데이터가 `Wafer_숫자_상태` 형식으로 붙어있을 때, 괄호 `()`를 쳐두면 원하는 부위만 깔끔하게 해체해서 튜플로 뱉어줘.

```python
status_log = "Processing W_015_Pass, W_016_Fail, W_017_Pass"

# 미션: W_ 뒤의 '숫자'와 뒤쪽의 '상태'만 분리해서 추출해라!
# 패턴 해석: W_(숫자들)_(알파벳들)
parsed = re.findall(r'W_(\d+)_([A-Za-z]+)', status_log)

print(parsed)
# 출력: [('015', 'Pass'), ('016', 'Fail'), ('017', 'Pass')] 
# (바로 DataFrame이나 딕셔너리에 박아넣기 최적의 상태!)

```
